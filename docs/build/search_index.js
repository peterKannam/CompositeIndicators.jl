var documenterSearchIndex = {"docs":
[{"location":"index.html","page":"Home","title":"Home","text":"Modules = [CompositeIndicators]","category":"page"},{"location":"index.html#Main.CompositeIndicators.Coin","page":"Home","title":"Main.CompositeIndicators.Coin","text":"Coin <: DataType\n\nDataType that stores a set of named dictionaries.\n\nThe dictionaries are used to contruct and analyse a composite indicator model.\n\n#Fields -input::Dict{Symbol,Any}:\n\n-data::Dict{Symbol,Any}:\n\n-weights::Dict{Symbol,Any}:\n\n-log::DataFrame:\n\n-results::Dict{Symbol,Any}:\n\n-figures::Dict{Symbol,Any}:\n\n\n\n\n\n","category":"type"},{"location":"index.html#Main.CompositeIndicators.ag_geomean-Tuple{Vector, StatsBase.AbstractWeights}","page":"Home","title":"Main.CompositeIndicators.ag_geomean","text":"ag_geomean(x::Vector,w::AbstractWeights)\n\nGeometric mean of x using weights w by sqrt(prod(x .^ Int.(w)).\n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.ag_mean-Tuple{Vector, StatsBase.AbstractWeights}","page":"Home","title":"Main.CompositeIndicators.ag_mean","text":"ag_mean(x::Vector,w::AbstractWeights)\n\nArithmetic mean of x using weights w by mean(x,w).\n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.ag_prod-Tuple{Vector, StatsBase.AbstractWeights}","page":"Home","title":"Main.CompositeIndicators.ag_prod","text":"ag_prod(x::Vector,w::AbstractWeights)\nProduct of `x` using ignoring weights `w` by `prod(x)`.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.aggregate!-Tuple{Main.CompositeIndicators.Coin, Symbol, Symbol}","page":"Home","title":"Main.CompositeIndicators.aggregate!","text":"aggregate!(coin,datakey,weightskey;...)\n\nAdd the DataFrame results of composite indicator aggregation of coin.data[datakey] by  coin.weights[weigtskey] to coin.data'[r_current] and coin.results[\"r_current\"].\n\nArguments\n\n-resultkey::String = \"current\":  key that results are saved as in coin.data coin.results.\n\n-ag_function::Function = ag_mean: function used to aggregate indicators of the same level.  Functions must take agruments (x::Vector,w::AbstractWeights).\n\n-ag_function_override::Tuple{Int64,Function} = (0,ag_mean): tuple of level and aggregation. function that is different than ag_function. Works only for a single level.\n\n-indicators2exclude::Vector = []: indicator columns to exclude in aggregation.\n\n-write2coin::Bool = true:  if results are saved to coin.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.get_meta-Tuple{Main.CompositeIndicators.Coin, Tuple{Union{String, Symbol}, Any}}","page":"Home","title":"Main.CompositeIndicators.get_meta","text":"get_meta(coin,colval_tup;column_out = names(coin.input[:indMeta]))\n\nReturn a DataFrame of a subset of the metadata. \n\nSubset specified by a tuple of column name and a value,  colval_tup::Tuple{Union{String,Symbol},Any}, and can  be further defined using the column_out keyword. \n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.get_meta-Tuple{Main.CompositeIndicators.Coin}","page":"Home","title":"Main.CompositeIndicators.get_meta","text":"get_meta(coin)\n\nReturn a DataFrame of a the metadata used to contruct the Coin.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.levelnormalizeweights!","page":"Home","title":"Main.CompositeIndicators.levelnormalizeweights!","text":"levelnormalizedweights!(coin::Coin,weightkey::Symbol = :w_original)\n\nAdd a column of weights that sum to 1 for each Level to the coin.weights[weightkey] DataFrame. Resulting weights for each indicator are proportional to the number of indicators it shares  a Parent indicator with and the Parent indicator weight. \n\nExamples\n\njulia> using DataFrames\n\njulia> w = DataFrame(:iCode=>[\"L1A\",\"L1B\",\"L1C\",\"L1D\",\"L2A\",\"L2B\",\"L3A\"],\n           :Level=>[1,1,1,1,2,2,3],\n           :Parent=>[\"L2A\",\"L2A\",\"L2B\",\"L2B\",\"L3A\",\"L3A\",\"NA\"],\n               :Weight=>[1,1,1,1,1,1,1])\n7×4 DataFrame\n Row │ iCode   Level  Parent  Weight \n     │ String  Int64  String  Int64  \n─────┼───────────────────────────────\n   1 │ L1A         1  L2A          1\n   2 │ L1B         1  L2A          1\n   3 │ L1C         1  L2B          1\n   4 │ L1D         1  L2B          1\n   5 │ L2A         2  L3A          1\n   6 │ L2B         2  L3A          1\n   7 │ L3A         3  NA           1\n\njulia> levelnormalizeweights!(w)\n7×5 DataFrame\n Row │ iCode   Level  Parent  Weight  WeightNorm \n     │ String  Int64  String  Int64   Float64    \n─────┼───────────────────────────────────────────\n   1 │ L1A         1  L2A          1        0.25\n   2 │ L1B         1  L2A          1        0.25\n   3 │ L1C         1  L2B          1        0.25\n   4 │ L1D         1  L2B          1        0.25\n   5 │ L2A         2  L3A          1        0.5\n   6 │ L2B         2  L3A          1        0.5\n   7 │ L3A         3  NA           1        1.0\n\njulia> w2 = copy(w);w2[5,:Weight] = 4;levelnormalizeweights!(w2)\n7×5 DataFrame\n Row │ iCode   Level  Parent  Weight  WeightNorm \n     │ String  Int64  String  Int64   Float64    \n─────┼───────────────────────────────────────────\n   1 │ L1A         1  L2A          1         0.4\n   2 │ L1B         1  L2A          1         0.4\n   3 │ L1C         1  L2B          1         0.1\n   4 │ L1D         1  L2B          1         0.1\n   5 │ L2A         2  L3A          4         0.8\n   6 │ L2B         2  L3A          1         0.2\n   7 │ L3A         3  NA           1         1.0\n\n\n\n\n\n","category":"function"},{"location":"index.html#Main.CompositeIndicators.new_coin-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"Main.CompositeIndicators.new_coin","text":"new_coin(indData,indMeta)\n\nReturn a new Coin object to represent a composite indicator model. \n\nIndicator data is defined by indData. Model structure and weighting scheme is defined by  indMeta.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.norm_competepercentile-Tuple{Vector}","page":"Home","title":"Main.CompositeIndicators.norm_competepercentile","text":"norm_competepercentile(x::Vector)\n\nReturn the percentile of each element of x where tied values are  assigned identical results. \n\nUses the competerank to rank values. missing values are assigned a result of missing.\n\nExamples\n\njulia> norm_competepercentile([0,0,1,2,2,3])\n6-element Vector{Float64}:\n 0.0\n 0.0\n 0.4\n 0.6\n 0.6\n 1.0\n\n julia> norm_competepercentile([0,0,1,2,missing,3])\n6-element Vector{Union{Missing, Float64}}:\n 0.0\n 0.0\n 0.5\n 0.75\n  missing\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.norm_minmax-Tuple{Vector}","page":"Home","title":"Main.CompositeIndicators.norm_minmax","text":"norm_minmax(x::Vector)\n\nReturn min-max normalization of x. \n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.norm_skipzeropercentile-Tuple{Vector}","page":"Home","title":"Main.CompositeIndicators.norm_skipzeropercentile","text":"norm_skipzeropercentile(x::Vector)\n\nReturn the percentile of each nonzero element of x where tied values are  assigned identical results.\n\nUses the competerank to rank nonzero values. '0' values are assigned a result of 0. missing values are assigned a result of missing.\n\n#Examples jldoctest julia> norm_skipzeropercentile([0,0,1,2,2,3]) 6-element Vector{Float64}:  0.0  0.0  0.0  0.3333  0.3333  1.0  ```jldoctest julia> norm_skipzeropercentile([0,0,1,2,missing,3]) 6-element Vector{Union{Missing, Float64}}:  0.0  0.0  0.0  0.5   missing  1.0\n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.normalize!-Tuple{Main.CompositeIndicators.Coin}","page":"Home","title":"Main.CompositeIndicators.normalize!","text":"normalize!(coin;norm_function::Function,datakey::String,normalizedkey::String)\n\nAdd a DataFrame of coin.data[datakey] normalized by  norm_function to coin.data[norm_*normalizedkey]. \n\nNormalize by applying norm_function to each column of the DataFrame. norm_function must take and return a Vector. If datakey is unspecified, apply norm_function to coin.data[\"original\"]. If normalizedkey is unspecified, add result with key norm_*String(Symbol(norm_function)).\n\n\n\n\n\n","category":"method"},{"location":"index.html#Main.CompositeIndicators.reaggregate_excludeindicator!-Tuple{Main.CompositeIndicators.Coin, Symbol}","page":"Home","title":"Main.CompositeIndicators.reaggregate_excludeindicator!","text":"reaggregate_excludeindicator!(coin,logkey;indicators2exclude)\n\nAdd the DataFrame results of composite indicator aggregation of coin.data[datakey] by  coin.weights[weigtskey] to coin.data'[r_current] and coin.results[\"r_current\"].\n\nCall the aggregate function using the arugments saved in the coin.log entry for logkey      excluding indicators in indicators2exclude. Results are saved as      coin.data'[Symbol(\"r_ex\",join(indicators2exclude))]\n\n\n\n\n\n","category":"method"}]
}
